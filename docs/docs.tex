\documentclass[letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}

\hypersetup{colorlinks, allcolors=blue}
\lstset {%
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    basicstyle=\ttfamily,
    numbers=left,
    numberstyle=\normalsize,
    numbersep=10pt,
    frame=single,
}
\setlength\parindent{0pt}

\begin{document}

\pagenumbering{gobble}
\vspace*{\fill}
\begin{center}
    \Large
    Documentation for Financial Transactions Web Application

    \large
    Jason N.

    June 1, 2020
\end{center}
\vspace*{\fill}

\newpage
\pagenumbering{roman}
\tableofcontents

\newpage
\pagenumbering{arabic}
\parskip 10pt

\section{Disclaimer}

This project is meant solely as a proof of concept to demonstrate how different databases might be used in this context.
The project is NOT meant to be used in production.
Several security flaws are present, including SQL injection, possible XSS, lack of authentication, etc.

\section{Setup}

This section is meant to serve as a general guide for setting up integrations used in this project.
The detail in this guide is limited as the process will depend heavily on your choices, which I have attempted to outline for you.
Many materials are referenced in this guide which contain far more detail, I would strongly suggest reading through these if they apply to your setup.

\subsection{Google API}

This is required for interacting with the Google Sheets database.

Go to https://console.developers.google.com/ and create a new project if you haven't already done that.

From the library panel, enable the Google Sheets API and the Google Drive API.

From the credentials panel, create an API key.

From the credentials panel, create an OAuth Client ID for a web application.
Give it a name, which will appear when users are prompted to give the app permissions.
Add the URIs that are expected to use the app.
When testing this locally, it can be useful to add http://localhost:5000 or similar.
These can always be changed at any moment from the developer console.

In the public/googleApiScript.js file of this repository, remember to change the client id and both instances of the api key to the appropriate values for your project.

\subsection{Firebase}

Firebase is used to host the web application and two of the databases, as well as storing images for all other databases to reference.
All features are available through the same firebase project.

To get started, simply navigate to https://console.firebase.google.com and click "Add Project".
Follow the instructions to set the name of the project and decide whether or not you want to make use of analytics.

Once a project has been created, follow the instructions at https://firebase.google.com/docs/web/setup to set up firebase with the front-end application.
If you are using the files in this repository, the necessary SDKs are already included, though you'll need to change the firebase config to the appropriate values for your project.

To set up the real-time database, follow the instructions at https://firebase.google.com/docs/database/web/start to create a database and get your real-time database url.
If you're using files from this repository, modify the firebase config to use this url instead of the given one.

To set up firestore, follow the instructions at https://firebase.google.com/docs/firestore/quickstart to create a database.
If you're using files from this repository, modify the contents of the object passed to the firebase.initializeApp() method to use appropriate values for your project.
This method is called in the public/firebaseScript.js file.

To set up cloud functions, follow the instructions at https://firebase.google.com/docs/functions/get-started.
If you're using files from this repository, the files already exist and just need to be deployed.

\subsection{MySQL}

There are several different implementations of MySQL available.
MariaDB was used to create and test this project, which is a fork of MySQL.

If you decide to host the database yourself, you'll need to start the program, log in, and create a database.
In this repository, it is named `mydb', however, this can be changed if desired.

Remember to change the ip address, database name, and credentials in the index.js file of the firebase cloud functions folder.

If you wish to use this repository, the database can be imported using the dump.txt file:

\lstinline{mysql -u username -p database_name < dump.txt}

Otherwise, once the database is created, enter the database using `use database name;' to enter the database.

To create tables, you can use the following query:

\lstinline{CREATE TABLE `name` ( `colname1` datatype, `colname2` datatype, `colname3` datatype... )}

Here is a useful website containing various MySQL commands: https://www.mysqltutorial.org/mysql-cheat-sheet.aspx/

\newpage

\section{HTML}\label{HTML}

\subsection{Preamble and head}

\subsubsection{Preamble}

Declares the document as HTML5.
\begin{lstlisting}[firstnumber=1]
<!DOCTYPE html>
\end{lstlisting}

\subsubsection{meta charset}

Specifies that characters in the file are encoded in UTF-8.
\begin{lstlisting}[firstnumber=4]
<meta charset = "UTF-8"/>
\end{lstlisting}

\subsubsection{link rel="stylesheet"}

Imports the CSS file.
\begin{lstlisting}[firstnumber=5]
<link rel="stylesheet" type="text/css" href="./style.css"/>
\end{lstlisting}

\subsubsection{Scripts}

Imports the main Javascript file, responsible for the table and UI.
\begin{lstlisting}[firstnumber=7]
<script src="./script.js"></script>
\end{lstlisting}

Imports the Google API library.
\begin{lstlisting}[firstnumber=8]
<script src="https://apis.google.com/js/api.js"></script>
\end{lstlisting}

Imports other Javascript files, responsible for database management.
\begin{lstlisting}[firstnumber=9]
<script src="./googleApiScript.js"></script>
<script src="./mysqlScript.js"></script>
<script src="./localStorageScript.js"></script>
<script src="./imageFirestore.js"></script>
\end{lstlisting}

\subsection{Inputs}

Disables autocomplete which remembers past user input by default. \lstinline{return false} specifies that no \lstinline{POST} request should be made to the server.
\begin{lstlisting}[firstnumber=20]
<form onsubmit="return false" autocomplete="off">
\end{lstlisting}

\subsubsection{Labels}

Identifies the purpose of the field to the user, allows the user to select the field by clicking the label.
This element is also used by accessibility tools to identify the field.
\begin{lstlisting}[firstnumber=22]
<label for="date">Date:</label><br/>
\end{lstlisting}

\subsubsection{Date}

The \lstinline{date} input type is supported by most modern browsers and provides an intuitive UI for selecting dates.
It also includes methods for converting or verifying the \lstinline{Date} object.
\begin{lstlisting}[firstnumber=13]
<input id="date" name="date" type="date" placeholder="yyyy-mm-dd"/>
\end{lstlisting}

\subsubsection{Text}

The \lstinline{text} input type allows the user to input a string. For numbers, this string has to be parsed in Javascript.
\begin{lstlisting}[firstnumber=28]
<input id="account" name="account" list="accountsList" type="text" placeholder="Account Number"/>
\end{lstlisting}

\subsubsection{List}

Lists are created using the \lstinline{select} element, containing \lstinline{option} elements.
Each option has a \lstinline{value} which is used in Javascript, and \lstinline{innerText} which is seen by the user.
\begin{lstlisting}[firstnumber=34]
<label for="type">Transaction Type:</label><br/>
<select id="type" name="type">
    <option value=""></option>
    <option value="BUY">BUY</option>
    <option value="SELL">SELL</option>
    <option value="!DIVIDEND">DIVIDEND</option>
    <option value="!INTEREST">INTEREST</option>
    <option value="!WITHDRAW">WITHDRAW</option>
    <option value="!DEPOSIT">DEPOSIT</option>
</select>
\end{lstlisting}

\subsubsection{File}

Files are uploaded using the \lstinline{file} input type.
The \lstinline{multiple} attribute allows the user to upload multiple files, which are interpreted as an array of files in Javascript.
\begin{lstlisting}[firstnumber=64]
    <label id="fileUploadLabel" for="fileUpload">Upload file</label>
    <input id="fileUpload" name="fileUpload" type="file" onchange="fileUploadChanged();" multiple/>
\end{lstlisting}

\subsubsection{Buttons}

Buttons with the \lstinline{submit} type can be used to check that all required sections are complete and highlight them in red.
These buttons can also be used to send a \lstinline{POST} request to a server if desired.
The \lstinline{onclick} attribute specified the function and parameters that should be executed when pressed.
\begin{lstlisting}[firstnumber=70]
<button id="add" type="submit" onclick="addTransactionButton();">Add Transaction</button>
\end{lstlisting}

\subsection{Filters}

Filter HTML elements are handled exactly the same as their counterparts in the input section.
Some fields have two elements to handle a lower and upper bound, but these are handled solely in Javascript.

\subsubsection{Tooltip}

The \lstinline{span} element is a generic container.
The \lstinline{title} attribute will display its value as a tool tip when the element is hovered.
\begin{lstlisting}[firstnumber=118]
<span title="Enter search terms here. Separate search terms with && or || for AND and OR statements, respectively. Exclusive filters are marked by a leading !. Use || to filter by multiple securities (e.g. SPY || TLT) and && to exclude multiple securities (e.g. !SPY && !TLT).">?</span><br/>
\end{lstlisting}

\subsubsection{Checkbox}

The input type \lstinline{checkbox} provides a toggleable input field which can be evaluated as \lstinline{true} or \lstinline{false} with Javascript.
\begin{lstlisting}[firstnumber=153]
<label for="filterNa">Filter N/A:</label>
<input id="filterNA" name="filterNA" type="checkbox"/>
\end{lstlisting}

\subsection{Options}

The options section uses buttons, text inputs, a file input, and drop down menus, which are decribed in the inputs section.
The special handling of these elements is done in Javascript.

\subsection{Table}

\subsection{frozenColumns}

Cells in columns that are meant to be always visible are marked with a \lstinline{frozenColumnx} class, where \lstinline{x} is the column number.
CSS is used to keep the column in place when scrolling.
\begin{lstlisting}[firstnumber=233]
<th class="frozenColumn1">
    <section>
        Transaction ID
    </section>
\end{lstlisting}

\subsection{sort buttons}

Sorting is done using buttons with an \lstinline{onclick} attribute that calls a function \lstinline{sortTable()}.
The parameters passed are the column index and a boolean value indicating whether the column should be sorted in ascending or descending order.
\begin{lstlisting}[firstnumber=237]
<section class="sort">
    <button type="button" onclick="sortTable(0, true)">^</button>
    <button type="button" onclick="sortTable(0, false)">v</button>
</section>
\end{lstlisting}

\subsubsection{tbody}

The main table body is initially empty.
Rows are managed by Javascript and it is marked with a unique id for this purpose.
\begin{lstlisting}[firstnumber=317]
<tbody id="tableBody">
</tbody>
\end{lstlisting}

\subsection{Firebase scripts}

These scripts are taken directly from the firebase documentation.
They are required for firebase and its components to function.
The \lstinline{firebase-app.js} script is the main script and is required for all firebase features.
The next three scripts are required for collecting analytics data, the realtime database, and firestore, respectively.

The configuration contains API keys and project information required to identify the app.
The key is not secret, though it is unique to the project.
As it is easily obtained by users of the app, it is strongly recommended to whitelist your domain in the project settings.

Unlike the other scripts, the firebase script is declared at the bottom, as it requires that the SDKs have loaded first.
\begin{lstlisting}[firstnumber=323]
<!-- The core Firebase JS SDK is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/7.14.2/firebase-app.js"></script>

<script src="https://www.gstatic.com/firebasejs/7.14.2/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.14.2/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.14.3/firebase-firestore.js"></script>

<script>
// Your web app's Firebase configuration
var firebaseConfig = {
    apiKey: "AIzaSyAmZLFZHDAB9evhvNunxOe5GxXRd_OizmU",
    authDomain: "financial-transactions-6f065.firebaseapp.com",
    databaseURL: "https://financial-transactions-6f065.firebaseio.com",
    projectId: "financial-transactions-6f065",
    storageBucket: "financial-transactions-6f065.appspot.com",
    messagingSenderId: "82206982479",
    appId: "1:82206982479:web:8937bbd1bd4fb6022b053a",
    measurementId: "G-0564DT8RNQ"
};
// Initialize Firebase
firebase.initializeApp(firebaseConfig);
firebase.analytics();

var database = firebase.database();
var firestore = firebase.firestore();
</script>

<script src="./firebaseScript.js"></script>
\end{lstlisting}

\newpage

\section{Main Javascript}\label{JS}

This file handles the UI and general functions required to bridge the front end with the databases.

\subsection{formattedStringToNumber()}

Removes leading dollar sign if present.
Removes all commas.
Converts string to a number datatype.

\begin{lstlisting}[firstnumber=1]
function formattedStringToNumber(numberAsString) {
    var number;

    if(numberAsString[0] == '$') {
        numberAsString = numberAsString.substr(1);
    }

    number = Number(numberAsString.replace(/,/g, ''));

    return number;
}
\end{lstlisting}

\subsection{numberToFormattedString()}

Converts number to string datatype.
Inserts a comma between every consecutive group of 3 characters.

\begin{lstlisting}[firstnumber=13]
function numberToFormattedString(number) {
    var numberAsString;

    numberAsString = String(number).replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    return numberAsString;
}
\end{lstlisting}

\subsection{getData()}

Gets values from input fields and performs minor formatting changes.
Calls the \lstinline{validate()} function to have the data verified.
If the data is valid, more formatting changes are performed, including adding dollar signs and converting the date to a string.
The function returns an array of the data if valid, \lstinline{false} otherwise.

\begin{lstlisting}[firstnumber=21]
function getData() {
    var date = document.getElementById("date");
    var account = document.getElementById("account").value;
    var type = document.getElementById("type").value;
    var security = document.getElementById("security").value;
    var amount = document.getElementById("amount").value;
    var dAmount = document.getElementById("dAmount").value;

    security = security.toUpperCase();

    amount = formattedStringToNumber(amount);

    dAmount = formattedStringToNumber(dAmount);

    if(validate(date, account, type, security, amount, dAmount)) {
        var costBasis = '$' + numberToFormattedString(calculateCostBasis(amount, dAmount));
        date = date.value;

        amount = numberToFormattedString(amount);
        dAmount = '$' + numberToFormattedString(dAmount.toFixed(2));

        return [ date, account, type, security, amount, dAmount, costBasis ];
    }
    else return false;
}
\end{lstlisting}

\subsection{validate()}

Calls functions to validate all input fields.
If any return \lstinline{false}, the \lstinline{validate()} function returns \lstinline{false}.
If none of the checks fail, the function returns \lstinline{true}.

\begin{lstlisting}[firstnumber=47]
function validate(date, account, type, security, amount, dAmount) {
    if(!validateDate(date)) return false;
    if(!validateAccount(account)) return false;
    if(!validateType(type)) return false;
    if(!validateSecurity(security)) return false;
    if(!validateAmount(amount)) return false;
    if(!validateDAmount(dAmount)) return false;

    return true;
}
\end{lstlisting}

\subsubsection{Check empty}

Checks if the input field is an empty string.
If so, alerts the user with an error message and returns \lstinline{false}.
Otherwise, returns \lstinline{true}.

\begin{lstlisting}[firstnumber=80]
function validateAccount(account) {
    if(account == '') {
        alert('Error: Missing Account Number');
        return false;
    }

    return true;
}
\end{lstlisting}

\subsubsection{Check NaN}

Uses the built-in \lstinline{isNaN()} function to check that a number is valid.

\begin{lstlisting}[firstnumber=107]
function validateAmount(amount) {
    if(amount == '') {
        alert('Error: Missing Amount');
        return false;
    }

    if(isNaN(amount)) {
        alert('Error: Invalid Amount');
        return false;
    }

    return true;
}
\end{lstlisting}

\subsubsection{Check date}

Gets the current date and stores it in the variable \lstinline{realDate}.
Checks the validity of the date input using the built-in \lstinline{date.checkValidity()}.
Compares the date input to the current date to ensure that the date input is not in the future.

\begin{lstlisting}[firstnumber=58]
function validateDate(date) {
    realDate = new Date();
    inputDate = date.valueAsNumber;

    if(date.value == '') {
        alert('Error: Missing date');
        return false;
    }

    if(!date.checkValidity()) {
        alert('Error: Invalid date');
        return false;
    }

    if(realDate.valueOf() < inputDate) {
        alert('Error: Date is in the future');
        return false;
    }

    return true;
}
\end{lstlisting}

\subsection{generateId()}

Generates an ID of length \lstinline{idLength} by selecting a random character from the character set using a loop.
Checks this ID against all other IDs in the table, if none match, the function returns the ID.
If any match, the ID is not unique and the function attempts to generate another until it reaches a unique ID.

\begin{lstlisting}[firstnumber=135]
function generateId() {
    var id = '';
    var idLength = 6;

    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    var charactersLength = characters.length;

    var unique = false;

    while(!unique) {
        for(var i = 0; i < idLength; i++) {
            id += characters.charAt(Math.floor(Math.random() * charactersLength));
        }

        unique = true;
        for(var i = 0; i < document.getElementsByClassName('idCell').length; i++) {
            if(document.getElementsByClassName('idCell')[i].innerText == id) {
                unique = false;
                break;
            }
        }
    }
    return id;
}
\end{lstlisting}

\subsection{calculateCostBasis()}

Divides the dollar amount by the amound and sets precision to 2 decimal places.

\begin{lstlisting}[firstnumber=160]
function calculateCostBasis(amount, dAmount) {
    costBasis = (dAmount / amount).toFixed(2);
    return costBasis;
}
\end{lstlisting}

\subsection{addTransaction()}

Takes an array as the argument, meant to contain all data necessary to create a row.
Constructs remaining cells in the row, such as the actions column, and formats the files column.
Adds the new row to the table and adds cells, modifying classes where necessary.

\begin{lstlisting}[firstnumber=165]
function addTransaction(data) {
    var staging = data;
    var tableBody = document.getElementById('tableBody');
    var newRow = tableBody.insertRow(0);
    newRow.classList += "bodyRow";

    var actionsContent = "<button type='button' onclick='editRow(this)'>Edit</button><button type='button' onclick='deleteRow(this)'>Delete</button>";
    var fileContent = '<table><tbody>';
    if(data.length > 8) {
        for(let i = 0; i < data[8].length; i++) {
            fileContent += "<tr><td><a onclick='downloadFile(`" + data[8][i][0] + "`);' href='javascript:void(0);'>" + data[8][i][1] + "</a></td>";
            fileContent += "<td><button type='button' onclick='removeFileFromTable(`" + data[8][i][0] + "`, this);'>-</button></td></tr>";
        }
    }
    fileContent += '</tbody></table><input type="file" onchange="addFile(this, 0);" multiple/>';
    staging[8] = fileContent;
    staging[9] = actionsContent;

    var calculateCostBasis = true;
    if(data[3][0] == '!') {
        calculateCostBasis = false;
        data[3] = data[3].substr(1);
    }

    for(var i = 0; i < 10; i++) {
        var newCell = newRow.insertCell(i);
        var idShowing = (document.getElementById('toggleId').innerText == "Hide Transaction ID");

        newCell.innerHTML = data[i];

        if(i == 0) {
            if(idShowing)
                newCell.classList = "idCell frozenColumn1";
            else {
                newCell.classList = "idCell";
                newCell.setAttribute("hidden", true);
            }
        }
        else if(i == 1) {
            if(idShowing)
                newCell.classList = "frozenColumn2";
            else
                newCell.classList = "frozenColumn1";
        }
        /*
        else if(i == 2) {
            if(idShowing)
                newCell.classList = "frozenColumn3";
            else
                newCell.classList = "frozenColumn2";
        }
        */

        if(i == 7 && !calculateCostBasis) {
            newCell.innerHTML = "N/A";
        }
    }
}
\end{lstlisting}

\subsection{fileIdGenerator()}

Creates and arbitrary, random file ID, large enough that it is extremely unlikely to generate two identical IDs.
This is done as it is less feasible to check existing databases for matching IDs.

\begin{lstlisting}[firstnumber=224]
function fileIdGenerator() {
    return Math.floor(Math.random() * 1000000000000000000000000000000000000000000).toString(36);
}
\end{lstlisting}

\subsection{addTransactionButton()}

Gets data by calling the \lstinline{getData()} function.
Adds the transaction ID to the \lstinline{data} array.
Creates a new empty array for storing file data, calls the \lstinline{uploadFile()} function to continue the process.

\begin{lstlisting}[firstnumber=228]
function addTransactionButton() {
    var data = getData();
    if(data) {
        var id = generateId();
        data.unshift(id);

        fileList = new Array()
        uploadFile(data, addTransactionWithFileName, fileList, 0);
        clearInput(false);
    }
}
\end{lstlisting}

\subsection{addTransactionWithFileName()}

Takes the row data as an argument and calls \lstinline{addTransaction()} to finalise the process.
Logs the data in the Javascript console.
Calls the \lstinline{loadDataLists()} function to update the list of securities and accounts lists.

\begin{lstlisting}[firstnumber=240]
function addTransactionWithFileName(data) {
    addTransaction(data);
    console.log(data);
    loadDataLists();
}
\end{lstlisting}

\subsection{deleteRow()}

Gets the row of the delete button.
Removes files from the local database which were referenced from this row (using the unique file ID).
Removes the row.
Resets the buttons in the input section if necessary (i.e. if the deleted row was being edited, the editing actions must be hidden and the add transaction button must be restored).

\begin{lstlisting}[firstnumber=246]
function deleteRow(button) {
    var row = button.parentElement.parentElement;

    var fileRows = row.getElementsByTagName('td')[8].getElementsByTagName('table')[0].getElementsByTagName('tr');
    for(let i = 0; i < fileRows.length; i++) {
        let fileId = fileRows[i].getElementsByTagName('a')[0].getAttribute('onclick').split('`')[1];
        deleteFileFromIndexedDB(fileId);
    }

    document.getElementById("tableBody").removeChild(row);

    if(document.getElementsByClassName('editing').length == 0) {
        document.getElementById('add').removeAttribute('hidden');
        document.getElementById('save').setAttribute('hidden', true);
        document.getElementById('discard').setAttribute('hidden', true);

        document.getElementById('add').setAttribute('type','submit');
        document.getElementById('save').setAttribute('type','button');
    }
    loadDataLists();
}
\end{lstlisting}

\subsection{editRow()}

The function checks if there is already a row with the \lstinline{editing} class.
If so, it removes this class from the old row.

The function then sets the current row to have the \lstinline{editing} class.
All the input fields are set to use values from the row.

In the case of type, the function first tries to apply the display value of the type.
If this fails, the function tries to add an exclamation mark to the front to account for the indication of types without cost basis.

The add transaction button is hidden and set to a regular button so that the enter key no longer activates it.
The save and discard buttons are unhidden, and save is set to the submit type button.

The file upload is cleared and the content of the file upload label is set depending on the number of files from the row.

\begin{lstlisting}[firstnumber=268]
function editRow(button) {
    if(document.getElementsByClassName('editing').length > 0)
        document.getElementsByClassName('editing')[0].classList = "bodyRow";

    var row = button.parentElement.parentElement;
    var rowContent = row.getElementsByTagName('td');
    row.classList = "bodyRow editing";

    document.getElementById('date').value = rowContent[1].innerText;
    document.getElementById('account').value = rowContent[2].innerText;

    document.getElementById('type').value = rowContent[3].innerText;
    if(document.getElementById('type').value == '') document.getElementById('type').value = '!' + rowContent[3].innerText;

    document.getElementById('security').value = rowContent[4].innerText;
    document.getElementById('amount').value = rowContent[5].innerText;
    document.getElementById('dAmount').value = rowContent[6].innerText;

    document.getElementById('add').setAttribute('hidden', true);
    document.getElementById('save').removeAttribute('hidden');
    document.getElementById('discard').removeAttribute('hidden');

    document.getElementById('add').setAttribute('type','button');
    document.getElementById('save').setAttribute('type','submit');

    removeFileUpload();
    uploadLabel = document.getElementById('fileUploadLabel');
    if(rowContent[8].getElementsByTagName('tr').length > 0) {
        uploadLabel.innerHTML = String(rowContent[8].getElementsByTagName('tr').length) + " file(s)";
    }
    fileEditted = false;
}
\end{lstlisting}

\subsection{saveChanges()}

The function attempts to get data from the input section by calling \lstinline{getData()}, which also validates this data.

The row to modify is determined by checking for the \lstinline{editing} class.
An array is created from the cells in this row.

If the first character of the type is and exclamation mark, this character is removed before being inserted into the row, and the cost basis is set to N/A.

Each element in the data array is moved into the appropriate cell in the row.

The add transaction button is restored, and the other buttons are hidden.

If the file upload was changed (i.e. a file was uploaded or the element was cleared), the \lstinline{uploadFile()} function is called to get the new files if they exist.
If no changes were made, the file input is cleared.

The date in the input is reset and all other fields are cleared.
Lastly, the function loads existing accounts and securities for the autofill feature.

\begin{lstlisting}[firstnumber=301]
function saveChanges() {
    data = getData();
    if(data) {
        rowToEdit = document.getElementsByClassName('editing')[0];
        cellsToEdit = rowToEdit.getElementsByTagName('td');

        if(data[2][0] == '!') {
            data[2] = data[2].substr(1);
            data[6] = "N/A";
        }

        for(var i = 0; i < data.length; i++) {
            cellsToEdit[i + 1].innerHTML = data[i];
        }
        rowToEdit.classList = "bodyRow";

        document.getElementById('add').removeAttribute('hidden');
        document.getElementById('save').setAttribute('hidden', true);
        document.getElementById('discard').setAttribute('hidden', true);

        document.getElementById('add').setAttribute('type','submit');
        document.getElementById('save').setAttribute('type','button');

        if(fileEditted) {
            uploadFile([cellsToEdit[8]], updateExistingFileName, new Array(), 0);
        }
        else {
            removeFileUpload();
        }

        resetDate();
        clearInput(true);
        loadDataLists();
    }
}
\end{lstlisting}

\subsection{discardChanges()}

The \lstinline{editing} class is removed from the row currently being edited.

The add transaction button is restored, and the other buttons are hidden.

The date is reset, input fields are cleared, and any files in the file upload are removed.

\begin{lstlisting}[firstnumber=337]
function discardChanges() {
    document.getElementsByClassName('editing')[0].classList = "bodyRow";

    document.getElementById('add').removeAttribute('hidden');
    document.getElementById('save').setAttribute('hidden', true);
    document.getElementById('discard').setAttribute('hidden', true);

    document.getElementById('add').setAttribute('type','submit');
    document.getElementById('save').setAttribute('type','button');

    resetDate();
    clearInput(true);
    removeFileUpload();
}
\end{lstlisting}

\subsection{sortTable()}

The function uses bubble sort to organise rows based on the column number specified by the first argument.
The condition evaluated is determined by whether the second argument is set to \lstinline{true} or \lstinline{false}.

\begin{lstlisting}[firstnumber=352]
function sortTable(column, ascending) {
    var rows = document.getElementsByClassName('bodyRow');

    var sorting = true;
    while(sorting) {
        sorting = false;
        for(var i = 0; i < (rows.length - 1); i++) {
            rowA = rows[i].getElementsByTagName('td')[column];
            rowB = rows[i + 1].getElementsByTagName('td')[column];

            var swap = false;

            if(ascending && rowA.innerHTML.toLowerCase() > rowB.innerHTML.toLowerCase()) swap = true;
            else if(!ascending && rowA.innerHTML.toLowerCase() < rowB.innerHTML.toLowerCase()) swap = true;

            if(swap) {
                sorting = true;
                document.getElementById('tableBody').insertBefore(rows[i + 1], rows[i]);
            }
        }
    }
}
\end{lstlisting}

\subsection{resetDate()}

A new \lstinline{Date} object is created to get the user's current date.
The year, month, and day of this object is organised to use the desired format.

Currently, this format is required to sort the table by date.
Changes to the format would require a special function for sorting dates to parse numbers and weight them correctly.

\begin{lstlisting}[firstnumber=375]
function resetDate() {
    const today = new Date();
    const year = new Intl.DateTimeFormat('en', { year: 'numeric' }).format(today);
    const month = new Intl.DateTimeFormat('en', { month: '2-digit' }).format(today);
    const day = new Intl.DateTimeFormat('en', { day: '2-digit' }).format(today);

    document.getElementById('date').value = `${year}-${month}-${day}`;
}
\end{lstlisting}

\subsection{clearInput()}

The type, security, amount, and dollar amount input fields are cleared.
If necessary, the account field is also cleared, depending on the value of the argument.

\begin{lstlisting}[firstnumber=384]
function clearInput(clearAccount) {
    if(clearAccount)
        document.getElementById('account').value = '';

    document.getElementById('type').value = '';
    document.getElementById('security').value = '';
    document.getElementById('amount').value = '';
    document.getElementById('dAmount').value = '';
}
\end{lstlisting}

\subsection{validateFilters()}

The function takes the filter input fields as arguments and sends each to a function created to validate the specific field.
The function returns \lstinline{false} if any checks fail, and \lstinline{true} otherwise.

\begin{lstlisting}[firstnumber=394]
function validateFilters(filterId, startDate, endDate, filterAccount, filterType, filterSecurity, minAmount, maxAmount, minDAmount, maxDAmount, minCostBasis, maxCostBasis) {
    if(!validateFilterId(filterId)) return false;
    if(!validateDateRange(startDate, endDate)) return false;
    if(!validateFilterAccount(filterAccount)) return false;
    if(!validateFilterSecurity(filterSecurity)) return false;
    if(!validateAmountRange(minAmount, maxAmount)) return false;
    if(!validateDAmountRange(minDAmount, maxDAmount)) return false;
    if(!validateCostBasisRange(minCostBasis, maxCostBasis)) return false;

    return true;
}
\end{lstlisting}

\subsubsection{always true}

Some filters require no validation.
These are set to always return \lstinline{true}.

\begin{lstlisting}[firstnumber=406]
function validateFilterId(id) {
    return true;
}
\end{lstlisting}

\subsubsection{date range}

The function checks that both dates in the range are valid dates.
The function then checks that the start date is not greater than the end date.

\begin{lstlisting}[firstnumber=410]
function validateDateRange(start, end) {
    if(!start.checkValidity()) {
        alert('Error: Invalid Start Date');
        return false;
    }

    if(!end.checkValidity()) {
        alert('Error: Invalid End Date');
        return false;
    }

    if(start.valueAsNumber > end.valueAsNumber) {
        alert('Error: Invalid Date Range');
        return false;
    }

    return true;
}
\end{lstlisting}

\subsubsection{amount range}

The function checks that both amounts are valid numbers.
The function then checks that the minimum is not greater than the maximum amount.

\begin{lstlisting}[firstnumber=437]
function validateAmountRange(min, max) {
    if(isNaN(Number(min))) {
        alert('Error: Min Amount is NaN');
        return false;
    }

    if(isNaN(Number(max))) {
        alert('Error: Max Amount is NaN');
        return false;
    }

    if(Number(min) > Number(max) && min != '' && max != '') {
        alert('Error: Invalid Amount Range');
        return false;
    }

    return true;
}
\end{lstlisting}

\subsection{stringFilter()}

For filters with more complex queries, top level queries are separated by AND operations.
These are subdivided by OR operations.

Within an AND block, any one OR must be true for the block to be true.
All AND blocks must be true for the query to succeed for the item checked.

\begin{lstlisting}[firstnumber=494]
function stringFilter(filtertext, tableitem) {
    filters = filtertext.split(" && ");

    for(var i = 0; i < filters.length; i++) {
        filterORs = filters[i].split(" || ");
        var meetsCriteria = false;

        for(var ii = 0; ii < filterORs.length; ii++) {
            if(filterORs[ii][0] == "!" && !tableitem.toUpperCase().includes(filterORs[ii].toUpperCase().substr(1))) meetsCriteria = true;
            if(filterORs[ii][0] != "!" && tableitem.toUpperCase().includes(filterORs[ii].toUpperCase())) meetsCriteria = true;
        }

        if(!meetsCriteria) return false;
    }

    return true;
}
\end{lstlisting}

\subsection{applyFilter()}

If the filter is valid, all previous filters are removed, and each column is filtered as necessary.
If any condition fails, the row is hidden.
Otherwise, the row remains visible.

\begin{lstlisting}[firstnumber=512]
function applyFilter() {
    unfilterAll();

    rows = document.getElementsByClassName('bodyRow');

    filterId = document.getElementById('filterId').value;
    startDate = document.getElementById('startDate');
    endDate = document.getElementById('endDate');
    filterAccount = document.getElementById('filterAccount').value;
    filterType = document.getElementById('filterType').value;
    filterSecurity = document.getElementById('filterSecurity').value;
    lowAmount = document.getElementById('lowAmount').value;
    highAmount = document.getElementById('highAmount').value;
    lowDAmount = document.getElementById('lowDAmount').value;
    highDAmount = document.getElementById('highDAmount').value;
    lowCostBasis = document.getElementById('lowCostBasis').value;
    highCostBasis = document.getElementById('highCostBasis').value;

    if(lowDAmount[0] == '$') lowDAmount = lowDAmount.substr(1);
    if(highDAmount[0] == '$') highAmount = highDAmount.substr(1);
    if(lowCostBasis[0] == '$') lowCostBasis = lowCostBasis.substr(1);
    if(highCostBasis[0] == '$') highCostBasis = highCostBasis.substr(1);

    if(validateFilters(filterId, startDate, endDate, filterAccount, filterType, filterSecurity, lowAmount, highAmount, lowDAmount, highDAmount, lowCostBasis, highCostBasis)) {
        for(var i = 0; i < rows.length; i++) {
            cells = rows[i].getElementsByTagName('td');
            var hide = false;

            if(filterId != '' && !stringFilter(filterId,cells[0].innerText))
                hide = true;

            if(startDate.value != '' && startDate.value > cells[1].innerText)
                hide = true;

            if(endDate.value != '' && endDate.value < cells[1].innerText)
                hide = true;

            if(filterAccount != '' && !stringFilter(filterAccount, cells[2].innerText))
                hide = true;

            if(filterType != '' && filterType != cells[3].innerText)
                hide = true;

            if(filterSecurity != '' && !stringFilter(filterSecurity, cells[4].innerText))
                hide = true;

            if(lowAmount != '' && Number(lowAmount) > formattedStringToNumber(cells[5].innerText))
                hide = true;

            if(highAmount != '' && Number(highAmount) < formattedStringToNumber(cells[5].innerText))
                hide = true;

            if(lowDAmount != '' && Number(lowDAmount) > formattedStringToNumber(cells[6].innerText.substr(1)))
                hide = true;

            if(highDAmount != '' && Number(highDAmount) < formattedStringToNumber(cells[6].innerText.substr(1)))
                hide = true;

            if(lowCostBasis != '' && Number(lowCostBasis) > formattedStringToNumber(cells[7].innerText.substr(1)))
                hide = true;

            if(highCostBasis != '' && Number(highCostBasis) < formattedStringToNumber(cells[7].innerText.substr(1)))
                hide = true;

            if(filterNA.checked && cells[7].innerText == "N/A")
                hide = true;

            if(hide)
                rows[i].setAttribute('hidden', true);
        }
    }
}
\end{lstlisting}

\subsection{clearFilter()}

All previous filters are removed by calling \lstinline{unfilterAll()}.
All filter fields are set to empty strings to clear them.
The checkbox is set to false to uncheck it.

\begin{lstlisting}[firstnumber=585]
function clearFilter() {
    unfilterAll();

    var fields = document.getElementsByClassName('filterField');

    for(var i = 0; i < fields.length; i++) {
        fields[i].value = '';
    }

    document.getElementById('filterNA').checked = false;
}
\end{lstlisting}

\subsection{unfilterAll()}

All previous filters are removed by unhiding all body rows.

\begin{lstlisting}[firstnumber=597]
function unfilterAll() {
    rows = document.getElementsByClassName('bodyRow');

    for(var i = 0; i < rows.length; i++) {
        rows[i].removeAttribute('hidden');
    }
}
\end{lstlisting}

\subsection{toggleID()}

Gets the current state of the ID column depending on the text of the button.

If the column needs to be hidden, the \lstinline{hidden} attribute is added to each ID cell.
Frozen column classes are shifted to remove the offset that would be created by the absence of these cells.

If the column needs to be revealed, the \lstinline{hidden} attribute is removed from each ID cell.
Frozen columns are shifted back to create room for the ID column.

\begin{lstlisting}[firstnumber=605]
function toggleID() {
    var button = document.getElementById('toggleId');
    var rows = document.getElementsByTagName('tr');
    var cells = rows[0].getElementsByTagName('th');

    if(button.innerText == "Hide Transaction ID") {
        button.innerText = "Show Transaction ID";

        cells[0].setAttribute('hidden', true);
        cells[0].classList = "";
        cells[1].classList = "frozenColumn1";
        //cells[2].classList = "frozenColumn2";
        for(var i = 1; i < rows.length; i++) {
            cells = rows[i].getElementsByTagName('td');

            cells[0].setAttribute('hidden', true);
            cells[0].classList = "idCell";
            cells[1].classList = "frozenColumn1";
            //cells[2].classList = "frozenColumn2";
        }
    }
    else {
        button.innerText = "Hide Transaction ID";

        cells[0].removeAttribute('hidden');
        cells[0].classList = "frozenColumn1";
        cells[1].classList = "frozenColumn2";
        //cells[2].classList = "frozenColumn3";
        for(var i = 1; i < rows.length; i++) {
            cells = rows[i].getElementsByTagName('td');

            cells[0].removeAttribute('hidden');
            cells[0].classList = "idCell frozenColumn1";
            cells[1].classList = "frozenColumn2";
            //cells[2].classList = "frozenColumn3";
        }
    }
}
\end{lstlisting}

\subsection{readFile()}

Gets the contents of a file and sets the value of the \lstinline{typesArray} element to these contents.

\begin{lstlisting}[firstnumber=644]
function readFile(fileIn){
    if(fileIn.files && fileIn.files[0]) {
        var reader = new FileReader();
        reader.onload = function (e) {
            var output = e.target.result;
            document.getElementById('typesArray').value = output;
        };
        reader.readAsText(fileIn.files[0]);
    }
}
\end{lstlisting}

\subsection{saveFile()}

The value of the \lstinline{typesArray} element is encoded for utf-8 and written to a file.
The user is prompted to download and save this file.

\begin{lstlisting}[firstnumber=655]
function saveFile() {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(document.getElementById('typesArray').value));
  element.setAttribute('download', 'transaction-types.csv');

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}
\end{lstlisting}

\subsection{applyTypes()}

The value of the \lstinline{typesArray} element is split by commas and saved as an array.
This array is passed as an argument to the \lstinline{setTransactionTypesList()} function.

\begin{lstlisting}[firstnumber=668]
function applyTypes() {
    var typesArray = document.getElementById('typesArray').value.split(',');
    setTransactionTypesList(typesArray);
}
\end{lstlisting}

\subsection{editTypes()}

The current types, which are read by \lstinline{readCurrentTypes()} are formatted as a comma-separated string and used to fill the \lstinline{typesArray} element.

\begin{lstlisting}[firstnumber=673]
function editTypes() {
    document.getElementById('typesArray').value = readCurrentTypes().join(',');
}
\end{lstlisting}

\subsection{setTransactionTypes()}

The existing lists of transaction types, which are found in the input and filter sections, are cleared.
Empty values are added to both to serve as default values.
New lists are created from the array passed to this function as an argument.
If the type is preceeded by an exclamation mark, this is kept in the \lstinline{value} attribute, but is not displayed to the user.

\begin{lstlisting}[firstnumber=677]
function setTransactionTypesList(typesArray) {
    var type = document.getElementById('type');
    var filterType = document.getElementById('filterType');

    type.innerHTML = '<option value=""></option>';
    filterType.innerHTML = '<option value=""></option>';

    for(var i = 0; i < typesArray.length; i++) {
        var typeAsText = typesArray[i];
        if(typesArray[i][0] == '!') typeAsText = typesArray[i].substr(1);

        type.innerHTML += '<option value="' + typesArray[i] + '">' + typeAsText + '</option>';
        filterType.innerHTML += '<option value="' + typeAsText + '">' + typeAsText + '</option>';
    }
}
\end{lstlisting}

\subsection{toggleSection()}

The section that the button belongs to is hidden or revealed, depending on the text of the button.
The text is updated to reflect the status of the section and the action that can be taken, whether hiding or revealing the section.

\begin{lstlisting}[firstnumber=693]
function toggleSection(button) {
    var form = button.parentElement.parentElement.getElementsByTagName('form')[0];

    if(button.innerText == "Hide") {
        form.setAttribute("hidden",true);
        button.innerText = "Show";
    }
    else {
        form.removeAttribute("hidden");
        button.innerText = "Hide";
    }
}
\end{lstlisting}

\subsection{loadDataLists()}

Arrays are constructed from unique strings found in the accounts and securities columns of the table.
These are used to create option elements for autofill suggestions in these fields.

\begin{lstlisting}[firstnumber=706]
function loadDataLists() {
    var accountsList = document.getElementById("accountsList");
    var securitiesList = document.getElementById("securitiesList");
    var rows = document.getElementsByClassName("bodyRow");

    var accounts = [];
    var securities = [];

    for(var i = 0; i < rows.length; i++) {
        var tableAccount = rows[i].getElementsByTagName("td")[2].innerText;
        var tableSecurity = rows[i].getElementsByTagName("td")[4].innerText;

        if(!accounts.includes(tableAccount)) accounts.push(tableAccount);
        if(!securities.includes(tableSecurity)) securities.push(tableSecurity);
    }

    accountsList.innerHTML = '';
    securitiesList.innerHTML = '';

    for(var i = 0; i < accounts.length; i++) {
        accountsList.innerHTML += '<option value="' + accounts[i] + '"/>';
    }

    for(var i = 0; i < securities.length; i++) {
        securitiesList.innerHTML += '<option value="' + securities[i] + '"/>';
    }
}
\end{lstlisting}

\subsection{readCurrentTypes()}

A list of current types saved as an array, created from the \lstinline{value} attributes of the options in the input dropdown menu.

\begin{lstlisting}[firstnumber=734]
function readCurrentTypes() {
    var types = document.getElementById('type').getElementsByTagName('option');
    var currentTypes = [];

    for(var i = 1; i < types.length; i++) {
        currentTypes.push(types[i].value);
    }

    return currentTypes;
}
\end{lstlisting}

\subsection{tableToArrays()}

The contents of each body row are saved in a two-dimensional array exactly as displayed, except for the file column, which is saved as a list of file names and IDs.

\begin{lstlisting}[firstnumber=745]
function tableToArrays() {
    var rows = document.getElementsByClassName('bodyRow');
    var data = new Array();
    data.push(["Transaction Id", "Date", "Account Number", "Transaction Type", "Security", "Amount", "$ Amount", "Cost Basis", "Files"]);

    for(var i = 0; i < rows.length; i++) {
        var cells = rows[i].getElementsByTagName('td');
        var cellData = new Array();

        for(var j = 0; j < 8; j++) {
            cellData.push(cells[j].innerText);
        }
        cellData.push(getFileNamesIds(cells[8]));
        data.push(cellData);
    }

    console.log(data);
    return data;
}
\end{lstlisting}

\subsection{arraysToTable()}

All current rows are removed from the table.
Buttons in the input field are set to the correct state for adding, as any row being edited would have been removed in the previous step.

For each row stored in the array, the function passes the data to the \lstinline{addTransactionButton}, starting with the last row saved.
This order is necessary as rows are added to the top of the table, so they must be read from the bottom to preserve order.

The row that was just added is popped from the array, allowing the function to proceed to the next row.
This loop continues as long as there are rows remaining in the array.

\begin{lstlisting}[firstnumber=765]
function arraysToTable(dataArr) {
    while(document.getElementsByClassName('bodyRow').length > 0) {
        document.getElementById("tableBody").removeChild(document.getElementsByClassName('bodyRow')[0]);
    }

    document.getElementById('add').removeAttribute('hidden');
    document.getElementById('save').setAttribute('hidden', true);
    document.getElementById('discard').setAttribute('hidden', true);

    document.getElementById('add').setAttribute('type', 'submit');
    document.getElementById('save').setAttribute('type', 'button');

    while(dataArr.length > 0) {
        let data = dataArr[dataArr.length - 1];
        let files = parseFileNamesIds(data[8]);
        data.pop();
        if(files.length > 0) {
            data.push(files);
        }
        addTransaction(data);
        dataArr.pop();
    }
    loadDataLists();
}
\end{lstlisting}

\subsection{window.onload = function()}

Once the page is loaded, the date is set to the current date and the local database is initialised.

\begin{lstlisting}[firstnumber=790]
window.onload = function() {
    resetDate();
    initDb();
}
\end{lstlisting}

\newpage

\section{firebaseScript.js}

Removes data stored under the \lstinline{Data} reference and the \lstinline{Types} reference.

\subsection{clearFirebase()}

\begin{lstlisting}[firstnumber=1]
function clearFirebase() {
    firebase.database().ref('Data').remove();
    firebase.database().ref('Types').remove();
}
\end{lstlisting}

\subsection{writeToFirebase()}

Clears the existing data using \lstinline{clearFirebase()}.
Creates an array from the table and an array containing types.
Contents of each array are written to the respective sections of the database.

\begin{lstlisting}[firstnumber=6]
function writeToFirebase() {
    writeImagesToFirestore("firebase");
    clearFirebase();

    var data = tableToArrays();
    var typesArr = readCurrentTypes();

    for(var i = 1; i < data.length; i++) {
        firebase.database().ref('Data/' + String(i - 1)).set({
            id: data[i][0],
            date: data[i][1],
            account: data[i][2],
            type: data[i][3],
            security: data[i][4],
            amount: data[i][5],
            dAmount: data[i][6],
            costBasis: data[i][7],
            files: data[i][8]
        });
    }
    for(var i = 0; i < typesArr.length; i++) {
        firebase.database().ref('Types/' + String(i)).set({
            value: typesArr[i]
        });
    }
}
\end{lstlisting}

\subsection{readFromFirebase()}

Takes a snapshot of the database at the time it is being read.

Passes the contents of each row to the \lstinline{addTransaction()} function.

Creates an array of transaction types from the database, passes this array as an argument to \lstinline{setTransactionTypesList()}.

Account and securities autofill suggestions are updated using \lstinline{loadDataLists()}.

\begin{lstlisting}[firstnumber=33]
function readFromFirebase() {
    clearIndexedDb("firebase");
    return firebase.database().ref('/').once('value').then(function(snapshot) {

        while(document.getElementsByClassName('bodyRow').length > 0) {
            document.getElementById("tableBody").removeChild(document.getElementsByClassName('bodyRow')[0]);
        }

        data = snapshot.val().Data;
        console.log(data);
        for(var i = data.length - 1; i >= 0; i--) {
            let staged = [data[i].id, data[i].date, data[i].account, data[i].type, data[i].security, data[i].amount, data[i].dAmount, data[i].costBasis];
            if(parseFileNamesIds(data[i].files).length > 0) {
                staged.push(parseFileNamesIds(data[i].files));
            }
            console.log(staged);
            addTransaction(staged);
        }

        types = snapshot.val().Types;
        var typesArr = [];
        for(var i = 0; i < types.length; i++) {
            typesArr.push(types[i].value);
        }
        setTransactionTypesList(typesArr);
        loadDataLists();
    });
}
\end{lstlisting}

\subsection{clearFirestore()}

The function reads the current Firestore database to get existing document IDs for data and types.
Each ID is removed from the database to allow new data to be written.

Note: This function is never called.
Instead, it has been used as a template for the \lstinline{writeToFirestore()}.

\begin{lstlisting}[firstnumber=62]
function clearFirestore() {
    firestore.collection("Data").get().then((querySnapshot) => {
        querySnapshot.forEach((doc) => {
            firestore.collection("Data").doc(doc.id).delete();
        });
    }).then(function() {
        firestore.collection("Types").get().then((querySnapshot) => {
            querySnapshot.forEach((doc) => {
                firestore.collection("Types").doc(doc.id).delete();
            });
        })
    }).then(function() { return 0 });
}
\end{lstlisting}

\subsection{writeToFirestore()}

Uses the template from the \lstinline{clearFirestore()} function to erase the current database.

When finished, creates documents for each row, containing all the necessary fields to recreate the row.
This document contains an index to preserve the order of the original table.

Creates a document for each type, containing the value of the type and an index to store the order in which it should be read.

\begin{lstlisting}[firstnumber=76]
function writeToFirestore() {
    writeImagesToFirestore("firestore");
    firestore.collection("Data").get().then((querySnapshot) => {
        querySnapshot.forEach((doc) => {
            firestore.collection("Data").doc(doc.id).delete();
        });
    }).then(function() {
        firestore.collection("Types").get().then((querySnapshot) => {
            querySnapshot.forEach((doc) => {
                firestore.collection("Types").doc(doc.id).delete();
            });
        }).then(function() {
            var data = tableToArrays();
            var typesArr = readCurrentTypes();

            for(var i = 1; i < data.length; i++) {
                firestore.collection("Data").add({
                    id: data[i][0],
                    date: data[i][1],
                    account: data[i][2],
                    type: data[i][3],
                    security: data[i][4],
                    amount: data[i][5],
                    dAmount: data[i][6],
                    costBasis: data[i][7],
                    files: data[i][8],
                    index: i - 1
                })
                .then(function(docRef) {
                    console.log("Document written with ID: ", docRef.id);
                })
                .catch(function(error) {
                    console.error("Error adding document: ", error);
                });
            }
            for(var i = 0; i < typesArr.length; i++) {
                firestore.collection("Types").add({
                    value: typesArr[i],
                    index: i
                })
                .then(function(docRef) {
                    console.log("Document written with ID: ", docRef.id);
                })
                .catch(function(error) {
                    console.error("Error adding document: ", error);
                });
            }
        })
    });
}
\end{lstlisting}

\subsection{readFromFirestore()}

Creates an array of rows, arranged in the original order using the stored \lstinline{index} property.
Creates an array of types using the same method.

Each row is written to the table using the \lstinline{addTransaction()} function, reading from the last item in the array to preserve the original order.
Account and security autofill suggestions are updated by calling \lstinline{loadDataLists()}.

The types array is passed to \lstinline{setTransactionTypes()} to update the transaction types.

\begin{lstlisting}[firstnumber=127]
function readFromFirestore() {
    clearIndexedDb("firestore");
    firestore.collection("Data").get().then((querySnapshot) => {
        var data = new Array();

        querySnapshot.forEach((doc) => {
            data[doc.data().index] = doc.data();
            console.log(data);
        });

        while(document.getElementsByClassName('bodyRow').length > 0) {
            document.getElementById("tableBody").removeChild(document.getElementsByClassName('bodyRow')[0]);
        }

        for(let i = data.length - 1; i >= 0; i--) {
            let staged = [data[i].id, data[i].date, data[i].account, data[i].type, data[i].security, data[i].amount, data[i].dAmount, data[i].costBasis];
            if(parseFileNamesIds(data[i].files).length > 0) {
                staged.push(parseFileNamesIds(data[i].files));
            }
            console.log(staged);
            addTransaction(staged);
        }
        loadDataLists();
    });

    firestore.collection("Types").get().then((querySnapshot) => {
        var typesArr = [];

        querySnapshot.forEach((doc) => {
            typesArr[doc.data().index] = doc.data().value;
        });

        setTransactionTypesList(typesArr);
    });
}
\end{lstlisting}

\newpage

\section{googleApiScript.js}

\subsection{Global Variables}

\begin{lstlisting}[firstnumber=1]
var auth2;

var spreadsheetId = "1R0HpaAIUw-JHX8SrzvkEPCG1qgI-siJ9oucY6g5e4Co";
var sheetId = "Sheet1";
var sheetIdNum = 0;
\end{lstlisting}

\subsection{loadSheetData()}

\begin{lstlisting}[firstnumber=7]
function loadSheetData() {
    if(auth2.isSignedIn.get())
    {
        getAllUserSheets();
    }
    else {
        authenticate()
            .then(function() {
                if(auth2.isSignedIn.get()) getAllUserSheets();
            });
    }
}
\end{lstlisting}

\subsection{getNewSheetData()}

\begin{lstlisting}[firstnumber=20]
function getNewSheetData() {
    spreadsheetId = document.getElementById('sheet').value;
    if(auth2.isSignedIn.get())
    {
        getTabsOfSheet();
    }
    else {
        authenticate()
            .then(function() {
                if(auth2.isSignedIn.get()) getTabsOfSheet();
            });
    }
}
\end{lstlisting}

\subsection{populateSheetSelector()}

\begin{lstlisting}[firstnumber=34]
function populateSheetSelector(arrayOfSheets) {
    document.getElementById('sheet').innerHTML = '<option value="1R0HpaAIUw-JHX8SrzvkEPCG1qgI-siJ9oucY6g5e4Co">default</option>';

    for(var i = 0; i < arrayOfSheets.length; i++) {
        document.getElementById('sheet').innerHTML += '<option value="' + arrayOfSheets[i].id + '">' + arrayOfSheets[i].name + '</option>';
    }
}
\end{lstlisting}

\subsection{getNewTabData()}

\begin{lstlisting}[firstnumber=42]
function getNewTabData() {
    data = document.getElementById('tab').value.split(/,(.+)/);
    sheetIdNum = data[0];
    sheetId = data[1];
}
\end{lstlisting}

\subsection{populateTabSelector()}

\begin{lstlisting}[firstnumber=48]
function populateTabSelector(arrayOfTabs) {
    document.getElementById('tab').innerHTML = '';

    for(var i = 0; i < arrayOfTabs.length; i++) {
        document.getElementById('tab').innerHTML += '<option value="' + arrayOfTabs[i].properties.sheetId + ',' + arrayOfTabs[i].properties.title + '">' + arrayOfTabs[i].properties.title + '</option>';
    }
}
\end{lstlisting}

\subsection{getAllUserSheets()}

\begin{lstlisting}[firstnumber=56]
function getAllUserSheets() {
    return gapi.client.drive.files.list({
        "pageSize": 1000,
        "orderBy": "name",
        "q": "mimeType = 'application/vnd.google-apps.spreadsheet'",
    })
        .then(function(response) {
            populateSheetSelector(JSON.parse(response.body).files);
            getNewSheetData();
            console.log("Response", response);
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{getTabsOfSheet()}

\begin{lstlisting}[firstnumber=70]
function getTabsOfSheet() {
    return gapi.client.sheets.spreadsheets.get({
      "spreadsheetId": spreadsheetId,
      "includeGridData": false
    })
        .then(function(response) {
            populateTabSelector(JSON.parse(response.body).sheets);
            getNewTabData();
            console.log("Response", response);
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{authenticate()}

\begin{lstlisting}[firstnumber=83]
function authenticate() {
return gapi.auth2.getAuthInstance()
    .signIn({scope: "https://www.googleapis.com/auth/drive"})
    .then(function() { console.log("Sign-in successful"); },
        function(err) { console.error("Error signing in", err); });
}
\end{lstlisting}

\subsection{loadClientSheets()}

\begin{lstlisting}[firstnumber=90]
function loadClientSheets() {
gapi.client.setApiKey("AIzaSyDC6JNuMW78Q-gWsp0PFEaTsICYjHWymAo");
return gapi.client.load("https://content.googleapis.com/discovery/v1/apis/sheets/v4/rest")
    .then(function() { console.log("GAPI client loaded for API"); loadSheetData(); },
        function(err) { console.error("Error loading GAPI client for API", err); });
}
\end{lstlisting}

\subsection{loadClient()}

\begin{lstlisting}[firstnumber=97]
function loadClient() {
gapi.client.setApiKey("AIzaSyDC6JNuMW78Q-gWsp0PFEaTsICYjHWymAo");
return gapi.client.load("https://content.googleapis.com/discovery/v1/apis/drive/v3/rest")
    .then(function() { console.log("GAPI client loaded for API"); loadClientSheets(); },
        function(err) { console.error("Error loading GAPI client for API", err); });
}
\end{lstlisting}

\subsection{readGoogleSheetDB()}

\begin{lstlisting}[firstnumber=104]
function readGoogleSheetDB() {
    clearIndexedDb("sheets");
    return gapi.client.sheets.spreadsheets.values.get({
        "spreadsheetId": spreadsheetId,
        "range": sheetId + "!A2:I214748354"
    })
        .then(function(response) {
            console.log("Response", response);

            dataArr = [];
            if(JSON.parse(response.body).values != undefined) {
                dataArr = JSON.parse(response.body).values;
            }
            arraysToTable(dataArr);

            readGoogleTypes();
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{readGoogleTypes()}

\begin{lstlisting}[firstnumber=124]
function readGoogleTypes() {
    return gapi.client.sheets.spreadsheets.values.get({
        "spreadsheetId": spreadsheetId,
        "range": sheetId + "!J1:J214748354",
        "majorDimension": "COLUMNS"

    })
        .then(function(response) {
            console.log("Response", response);
            var typesArr = JSON.parse(response.body).values[0];
            setTransactionTypesList(typesArr);
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{writeGoogleSheetDB()}

\begin{lstlisting}[firstnumber=139]
function writeGoogleSheetDB() {
    if(auth2.isSignedIn.get())
    {
        setGoogleRows()
    }
    else {
        authenticate()
            .then(function() {
                if(auth2.isSignedIn.get()) setGoogleRows();
            });
    }
}
\end{lstlisting}

\subsection{setGoogleRows()}

\begin{lstlisting}[firstnumber=152]
function setGoogleRows() {
    return gapi.client.sheets.spreadsheets.batchUpdate({
        "spreadsheetId": spreadsheetId,
        "resource": {
        "requests": [
            {
            "updateSheetProperties": {
                "properties": {
                    "gridProperties": {
                        "columnCount": 10,
                        "rowCount": 1
                },
                    "sheetId": sheetIdNum
                },
                "fields": "gridProperties"
            }
            }
        ]
        }
    })
        .then(function(response) {
            console.log("Response", response);

            clearGoogleRow();
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{clearGoogleRow()}

\begin{lstlisting}[firstnumber=180]
function clearGoogleRow() {
    return gapi.client.sheets.spreadsheets.values.clear({
    "spreadsheetId": spreadsheetId,
    "range": sheetId + "!A1:J1",
    "resource": {}
    })
        .then(function(response) {
            console.log("Response", response);

            writeGoogleDB();
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{writeGoogleDB()}

\begin{lstlisting}[firstnumber=194]
function writeGoogleDB() {
    writeImagesToFirestore("sheets");
    return gapi.client.sheets.spreadsheets.values.batchUpdate({
        "spreadsheetId": spreadsheetId,
        "resource": {
            "data": [
            {
                "range": sheetId + "!A1",
                "values": tableToArrays(),
                "majorDimension": "ROWS"
            },
            {
                "range": sheetId + "!J1",
                "values": [readCurrentTypes()],
                "majorDimension": "COLUMNS"
            }
            ],
            "valueInputOption": "RAW"
        }
        })
        .then(function(response) {
            console.log("Response", response);
        },
        function(err) { console.error("Execute error", err); });
}
\end{lstlisting}

\subsection{gapi.load()}

\begin{lstlisting}[firstnumber=220]
gapi.load("client:auth2", function() {
    auth2 = gapi.auth2.init({client_id: "217251662395-9pu2qa1hubgrblav1nhvnfaascd6povv.apps.googleusercontent.com"});
    loadClient();
});
\end{lstlisting}

\newpage

\section{imageFirestore.js}

\subsection{writeImagesToFirestore()}

\begin{lstlisting}[firstnumber=1]
function writeImagesToFirestore(database) {
    firestore.collection("Images:" + database).get().then((querySnapshot) => {
        querySnapshot.forEach((doc) => {
            firestore.collection("Images:" + database).doc(doc.id).delete();
        });
    }).then(function() {
        var trans = db.transaction(['files'], 'readonly');
        var dlReq = trans.objectStore('files').getAll();

        dlReq.onerror = function(e) {
            console.log('error reading data');
            console.error(e);
        };

        dlReq.onsuccess = function(e) {
            console.log(dlReq.result);

            for(let i = 0; i < dlReq.result.length; i++) {
                firestore.collection("Images:" + database).add({
                    id: dlReq.result[i].id,
                    type: dlReq.result[i].type,
                    name: dlReq.result[i].name,
                    data: dlReq.result[i].data,
                })
                .then(function(docRef) {
                    console.log("Image written with ID: ", docRef.id);
                })
                .catch(function(error) {
                    console.log("Error adding image: ", error);
                });
            }
        };
    });
}
\end{lstlisting}

\subsection{readImagesFromFirestore()}

\begin{lstlisting}[firstnumber=36]
function readImagesFromFirestore(database) {
    firestore.collection("Images:" + database).get().then((querySnapshot) => {
        let trans = db.transaction(['files'], 'readwrite');

        trans.oncomplete = function(e) {
            console.log('data stored');
        }

        querySnapshot.forEach((doc) => {
            console.log("Writing ", doc.data().name);

            let ob = {
                id: doc.data().id,
                type: doc.data().type,
                name: doc.data().name,
                data: doc.data().data
            };

            let addReq = trans.objectStore('files').put(ob);
        });
    });
}
\end{lstlisting}

\subsection{getFileNamesIds()}

\begin{lstlisting}[firstnumber=59]
function getFileNamesIds(cell) {
    var links = cell.getElementsByTagName('a');
    var result = '';

    for(let i = 0; i < links.length; i++) {
        result += links[i].innerText + '/' + links[i].getAttribute('onclick').split('`')[1] + '/';
    }

    return result;
}
\end{lstlisting}

\subsection{parseFileNamesIds()}

\begin{lstlisting}[firstnumber=70]
function parseFileNamesIds(string) {
    var result = new Array();

    if(string != '') {
        let strarr = string.split('/');
        for(let i = 0; i < strarr.length - 1; i += 2) {
            result.push([strarr[i + 1], strarr[i + 0]]);
        }
    }

    return result;
}
\end{lstlisting}

\subsection{clearIndexedDb()}

\begin{lstlisting}[firstnumber=83]
function clearIndexedDb(database) {
    console.log("db reset");
    let trans = db.transaction(['files'], 'readwrite');
    var clearReq = trans.objectStore('files').clear();

    trans.oncomplete = function(e) {
        readImagesFromFirestore(database);
    }
}
\end{lstlisting}

\newpage

\section{localStorageScript.js}

\subsection{Global Variables}

\begin{lstlisting}[firstnumber=1]
let db;
let dbVersion = 1;
let dbReady = false;

var fileEditted = false;
\end{lstlisting}

\subsection{initDb()}

\begin{lstlisting}[firstnumber=7]
function initDb() {
    let reset = indexedDB.deleteDatabase('FileStorage');
    reset.onsuccess = function(a) {
        let request = indexedDB.open('FileStorage', dbVersion);

        request.onerror = function(e) {
            console.error('Unable to open database.');
        }

        request.onsuccess = function(e) {
            db = e.target.result;
            console.log('db opened');
        }

        request.onupgradeneeded = function(e) {
            let db = e.target.result;
            db.createObjectStore('files', {keyPath:'id', autoIncrement: false});
            dbReady = true;
        }
    }
}
\end{lstlisting}

\subsection{fileUploadChanged()}

\begin{lstlisting}[firstnumber=29]
function fileUploadChanged() {
    fileIn = document.getElementById('fileUpload');
    if(fileIn.files && fileIn.files[0]) {
        document.getElementById('fileUploadLabel').innerHTML = String(fileIn.files.length) + " file(s)";
    }
    fileEditted = true;
    console.log("updated file upload");
}
\end{lstlisting}

\subsection{uploadFile()}

\begin{lstlisting}[firstnumber=38]
function uploadFile(data, cb, fileList, index) {
    fileId = fileIdGenerator();
    fileIn = document.getElementById('fileUpload');
    if(fileIn.files && fileIn.files[index]) {
        var reader = new FileReader();
        reader.onload = function (e) {
            console.log(e.target.result);

            let bits = btoa(e.target.result);
            let ob = {
                id: fileId,
                type: fileIn.files[index].type,
                name: fileIn.files[index].name,
                data: bits
            };

            let trans = db.transaction(['files'], 'readwrite');
            let addReq = trans.objectStore('files').put(ob);

            addReq.onerror = function(e) {
                console.log('error storing data');
                console.error(e);
            }

            trans.oncomplete = function(e) {
                console.log('data stored');
                fileList.push([fileId, fileIn.files[index].name]);
                index++;
                uploadFile(data, cb, fileList, index);
            }
        };
        reader.readAsBinaryString(fileIn.files[index])
    }
    else {
        removeFileUpload();
        data.push(fileList);
        cb(data);
    }
}
\end{lstlisting}

\subsection{addFile()}

\begin{lstlisting}[firstnumber=78]
function addFile(fileIn, index) {
    fileId = fileIdGenerator();
    if(fileIn.files && fileIn.files[index]) {
        var reader = new FileReader();
        reader.onload = function (e) {
            console.log(e.target.result);

            let bits = btoa(e.target.result);
            let ob = {
                id: fileId,
                type: fileIn.files[index].type,
                name: fileIn.files[index].name,
                data: bits
            };

            let trans = db.transaction(['files'], 'readwrite');
            let addReq = trans.objectStore('files').put(ob);

            addReq.onerror = function(e) {
                console.log('error storing data');
                console.error(e);
            }

            trans.oncomplete = function(e) {
                console.log('data stored');
                let table = fileIn.parentElement.getElementsByTagName('tbody')[0];
                let newRowContent = "<tr><td><a onclick='downloadFile(`" + fileId + "`);' href='javascript:void(0);'>" + fileIn.files[index].name + "</a></td>";
                newRowContent += "<td><button type='button' onclick='removeFileFromTable(`" + fileId + "`, this);'>-</button></td></tr>";
                table.innerHTML += newRowContent;
                index++;
                addFile(fileIn, index);
            }
        };
        reader.readAsBinaryString(fileIn.files[index])
    }
    else {
        fileIn.value = null;
    }
}
\end{lstlisting}

\subsection{updateExistingFileName()}

\begin{lstlisting}[firstnumber=118]
function updateExistingFileName(data) {
    for(let i = 0; i < data[0].getElementsByTagName('tr').length; i++) {
        let fileId = data[0].getElementsByTagName('tr')[i].getElementsByTagName('a')[0].getAttribute('onclick').split('`')[1];
        deleteFileFromIndexedDB(fileId);
    }

    var fileContent = '<table><tbody>';
    if(data.length > 1) {
        for(let i = 0; i < data[1].length; i++) {
            fileContent += "<tr><td><a onclick='downloadFile(`" + data[1][i][0] + "`);' href='javascript:void(0);'>" + data[1][i][1] + "</a></td>";
            fileContent += "<td><button type='button' onclick='removeFileFromTable(`" + data[1][i][0] + "`, this);'>-</button></td></tr>";
        }
    }
    fileContent += '</tbody></table><input type="file" onchange="addFile(this, 0);" multiple/>';
    data[0].innerHTML = fileContent;
}
\end{lstlisting}

\subsection{removeFileFromTable()}

\begin{lstlisting}[firstnumber=135]
function removeFileFromTable(fileId, cell) {
    var row = cell.parentElement.parentElement;

    if(confirm("Delete " + row.getElementsByTagName('a')[0].innerText + "?")) {
        row.parentElement.removeChild(row);
        deleteFileFromIndexedDB(fileId);
    }
}
\end{lstlisting}

\subsection{deleteFileFromIndexedDB()}

\begin{lstlisting}[firstnumber=144]
function deleteFileFromIndexedDB(fileId) {
    let trans = db.transaction(['files'], 'readwrite');
    let addReq = trans.objectStore('files').delete(fileId);
}
\end{lstlisting}

\subsection{removeFileUpload()}

\begin{lstlisting}[firstnumber=149]
function removeFileUpload() {
    document.getElementById('fileUpload').value = null;
    document.getElementById('fileUploadLabel').innerHTML = "Upload file";
    fileEditted = true;
}
\end{lstlisting}

\subsection{downloadFile()}

\begin{lstlisting}[firstnumber=155]
function downloadFile(fileId) {
    console.log('downloading');
    var trans = db.transaction(['files'], 'readonly');
    var dlReq = trans.objectStore('files').get(fileId);

    dlReq.onerror = function(e) {
        console.log('error reading data');
        console.error(e);
    };

    dlReq.onsuccess = function(e) {
        console.log('data read');
        console.log(dlReq.result);
        var element = document.createElement('a');
        element.setAttribute('href', 'data:' + dlReq.result.type + ';base64,' + dlReq.result.data);
        element.setAttribute('download', dlReq.result.name);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    };
}
\end{lstlisting}

\subsection{window.onbeforeunload = function()}

\begin{lstlisting}[firstnumber=1]
window.onbeforeunload = function(){
    indexedDB.deleteDatabase('FileStorage');
}
\end{lstlisting}

\newpage

\section{mysqlScript.js}

\subsection{writeToMySQL()}

\begin{lstlisting}[firstnumber=1]
function writeToMySQL() {
    writeImagesToFirestore("mysql");
    var data = tableToArrays();
    var types = readCurrentTypes();

    fetch('http://localhost:5000/api', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify([data, types]),
    });
}
\eng{lstlisting}

\subsection{readFromMySQL()}

\begin{lstlisting}[firstnumber=15]
function readFromMySQL() {
    clearIndexedDb("mysql");
    fetch('http://localhost:5000/api')
        .then(response => {
            return response.json()
        })
        .then(fullresponse => {
            console.log(fullresponse);

            while(document.getElementsByClassName('bodyRow').length > 0) {
                document.getElementById("tableBody").removeChild(document.getElementsByClassName('bodyRow')[0]);
            }

            var data = fullresponse[0];
            for(var i = data.length - 1; i >= 0; i--) {
                let staged = [data[i].id, data[i].date, data[i].account, data[i].type, data[i].security, data[i].amount, data[i].dAmount, data[i].costBasis];
                if(parseFileNamesIds(data[i].files).length > 0) {
                    staged.push(parseFileNamesIds(data[i].files));
                }
                addTransaction(staged);
            }
            loadDataLists();

            var types = fullresponse[1];
            var typesArr = [];
            for(var i = 0; i < types.length; i++) {
                typesArr.push(types[i].typename);
            }
            setTransactionTypesList(typesArr);
        })
}
\end{lstlisting}

\newpage

\section{NodeJs}\label{NodeJs}

\subsection{Dependencies}

\begin{lstlisting}[firstnumber=1]
const functions = require('firebase-functions');
const express = require('express');
const mysql = require('mysql');
const cors = require('cors');
const api = express();
api.use(cors({ origin: true }));
\end{lstlisting}

\subsection{mysql.createConnection()}

\begin{lstlisting}[firstnumber=8]
var con = mysql.createConnection({
    host: "localhost",
    user: "user",
    password: "pass",
    database: "mydb"
});
\end{lstlisting}

\subsection{con.connect()}

\begin{lstlisting}[firstnumber=15]
con.connect(function(err) {
    if (err) throw err;
    console.log("Connected to MySQL Database!");
});
\end{lstlisting}

\subsection{readDataFromMySQL()}

\begin{lstlisting}[firstnumber=20]
function readDataFromMySQL(cb) {
    con.query("SELECT * FROM data;", function (err, data, fields) {
        if (err) throw err;
        cb(data);
    });
}
\end{lstlisting}

\subsection{readTypesFromMySQL()}

\begin{lstlisting}[firstnumber=27]
function readTypesFromMySQL(cb) {
    con.query("SELECT * FROM types;", function (err, types, fields) {
        if (err) throw err;
        cb(types);
    });
}
\end{lstlisting}

\subsection{writeToMySQL()}

\begin{lstlisting}[firstnumber=34]
function writeToMySQL(jsonData) {
    var data = jsonData[0];
    var types = jsonData[1];

    con.query("TRUNCATE TABLE data;");

    for(var i = 1; i < data.length; i++) {
        con.query("INSERT INTO data (id, date, account, type, security, amount, dAmount, costBasis, files) VALUES ('" + data[i].join("','") + "');");
    }

    con.query("TRUNCATE TABLE types;");

    for(var i = 0; i < types.length; i++) {
        con.query("INSERT INTO types (typename) VALUES ('" + types[i] + "');");
    }
}
\end{lstlisting}

\subsection{api.post()}

\begin{lstlisting}[firstnumber=51]
api.post('/api', (req, res) => {
    console.log(req.body);
    writeToMySQL(req.body);
    return res.status(200).send(req.body);
});
\end{lstlisting}

\subsection{api.get()}

\begin{lstlisting}[firstnumber=57]
api.get('/api', (req, res) => {
    readDataFromMySQL(function(data) {
        console.log(data);
        readTypesFromMySQL(function(types) {
            console.log(types);
            return res.status(200).send([ data, types ]);
        });
    });
});
\end{lstlisting}

\subsection{exports.api}

\begin{lstlisting}[firstnumber=67]
exports.api = functions.https.onRequest(api);
\end{lstlisting}

\newpage

\section{CSS}\label{CSS}

\subsection{Vertical Scrolling Table}
\subsection{Horizontal Scrolling on Overflow}\label{overflow-x}
\subsection{Miscellaneous}
\subsubsection{Sort buttons}
\subsubsection{Editing highlight}
\subsubsection{Table borders}

%\newpage
%
%\appendix
%\section{HTML Source Code}
%\lstinputlisting{../release/public/index.html}
%\newpage
%
%\section{Javascript Source Code}
%\subsection{Main Script}
%\lstinputlisting{../release/public/script.js}
%\newpage
%\subsection{Google API Script}
%\lstinputlisting{../release/public/googleApiScript.js}
%\newpage
%\subsection{Firebase Script}
%\lstinputlisting{../release/public/firebaseScript.js}
%\newpage
%\subsection{MySQL Script}
%\lstinputlisting{../release/public/mysqlScript.js}
%\newpage
%\subsection{Local Storage Script}
%\lstinputlisting{../release/public/localStorageScript.js}
%\newpage
%\subsection{Firestore Images Script}
%\lstinputlisting{../release/public/imageFirestore.js}
%\newpage
%
%\section{CSS Source Code}
%\lstinputlisting{../release/public/style.css}
%\newpage
%
%\section{Server-side NodeJs Code}
%\lstinputlisting{../release/functions/index.js}

\end{document}

